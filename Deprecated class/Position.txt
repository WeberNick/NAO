This is code which was done on the assumption that we would use absolute coordinates on the field.
this class was completely dumped, but it remains within the code to show that I did something during our project.
Jonas

package foundation.data;
/**
 * 
 * @author Jonas Thietke and Julian Betz
 * this class contains a position for an object and implements vector calculation
 * @deprecated
 * 
 */
public class Position {
	private float x;
	private float y;
	private float z;
	public Position (float x, float y, float z){
		this.x=x;
		this.y=y;
		this.z=z;
	}
	public float getX() {
		return x;
	}
	public void setX(float x) {
		this.x = x;
	}
	public float getY() {
		return y;
	}
	public void setY(float y) {
		this.y = y;
	}
	public float getZ() {
		return z;
	}
	public void setZ(float z) {
		this.z = z;
	}
/**
 * the position is seen as a vector containing the direction to this position. It returns a vector
 * (wrapped in a Position object) leading from p2 to the position on which the method is invoked.
 * @param p2 .
 * @return .
 */
	public Position vectorSub(Position p2){
		return new Position (this.x-p2.getX(),y-p2.getY(),z-p2.getZ());
	}
	
	/**
	 * the Position is seen as a vector.
	 * @param p2 the vector to be added
	 * @return a vector leading from the origin to "this+p2"
	 */
	public Position vectorAdd(Position p2){
		return new Position (x+p2.getX(),y+p2.getY(),z+p2.getZ());
	}
	/**
	 * the Position is is seen as a vector.
	 * @return a new vector containing the Position turned 90 clockwise.
	 */
	public Position vectorTurn2D(){
		Position result = new Position(x,y,z);
		for(int i=0;i<3;i++){
			result=new Position(-y,x,z);
		}
		return result;
	}
	/**
	 * as we do not expect positions to be always exactly the same, 
	 * this method will return if a given position fits round about the one of this instance.
	 * it could be seen as some kind of 'equals'
	 * @param p the position to be compared with the object
	 * @return true if they fit, false if not.
	 */
	public boolean fits(Position p){
		float tolerance =0.1f;
		if (p.getX()-x<=tolerance || x-p.getX()<=tolerance){
//			if (p.getX()<=(x-tolerance)){
//				if (p.getY()<=(y+tolerance)){
//					if (p.getY()>=(y-tolerance)){
//						if (p.getZ()<=(z+tolerance)){
//							if (p.getZ()>=(z-tolerance)){
								return true;
//							}
//						}
//					}
//				}
//			}
		}
		return false;
	}
}

This method was part of Playboard.java
it is not used in the code.
/**
 * this method will set all position attributes from 6 points to be given by controller/NAO.
 * These points are
 * @param pos1 position of field 1
 * @param pos2 position of field 2
 * @param pos4 position of field 4
 * @param pos5 position of field 5
 * @param pos7 position of field 7
 * @param pos8  position of field 
 * @deprecated
 */
public void constructFromPositions(Position pos1, Position pos2,Position pos4,Position pos5,Position pos7,Position pos8){
	//set given
	fields[1].setPosition(pos1);
	fields[2].setPosition(pos2);
	fields[4].setPosition(pos4);
	fields[5].setPosition(pos5);
	fields[7].setPosition(pos7);
	fields[8].setPosition(pos8);
	
	//set outer ring
	Position $2_1 = pos1.vectorSub(pos2);
	Position f0 = pos1.vectorAdd($2_1);
	fields[0].setPosition(f0);
	Position $2_14 = $2_1.vectorTurn2D();
	fields[14].setPosition(pos2.vectorAdd($2_14));
	fields[23].setPosition(fields[14].getPosition().vectorAdd($2_14));
	fields[22].setPosition(fields[23].getPosition().vectorAdd($2_1));
	fields[21].setPosition(fields[22].getPosition().vectorAdd($2_1));
	fields[9].setPosition(f0.vectorAdd($2_14));
	
	//set middel ring
	Position $5_4 = pos4.vectorSub(pos5);
	fields[3].setPosition(pos4.vectorAdd($5_4));
	Position $5_13 = $5_4.vectorTurn2D();
	fields[13].setPosition(pos5.vectorAdd($5_13));
	fields[20].setPosition(fields[13].getPosition().vectorAdd($5_13));
	fields[19].setPosition(fields[20].getPosition().vectorAdd($5_4));
	fields[18].setPosition(fields[19].getPosition().vectorAdd($5_4));
	fields[10].setPosition(fields[3].getPosition().vectorAdd($5_13));
	
	//set inner ring
	Position $8_7 = pos7.vectorSub(pos8);
	fields[6].setPosition(pos7.vectorAdd($8_7));
	Position $8_12 = $8_7.vectorTurn2D();
	fields[12].setPosition(pos8.vectorAdd($8_12));
	fields[17].setPosition(fields[12].getPosition().vectorAdd($8_12));
	fields[16].setPosition(fields[17].getPosition().vectorAdd($8_7));
	fields[15].setPosition(fields[16].getPosition().vectorAdd($8_7));
	fields[11].setPosition(fields[6].getPosition().vectorAdd($8_12));
}